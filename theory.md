# 理论知识点
### QA summary
- 操作符endl作用：输出换行符并刷新输出流
- Hex操纵符将整数输出的进制设置为十六进制
- Scientific用于设置浮点数为科学计数法格式
- C++命名空间作用：避免全局标识符的名字冲突
- 对于以下代码：
  ```cpp
  #include<iostream>
  using namespace std;
  int main(){
    int cout;
    cin>>cout;
    std::cout<<(cout<<cout);
  }
  ```
  输入为2，则输出为8：cout值为2，cout << cout相当于 2<<2，相当于二进制左移2位（10 -> 1000），即十进制的8
- 引用必须被定义，且不能为空
- Fixed默认小数点后六位
- substr(起始位置，字串长度)：取从起始位置起长度为字串长度的子串
- find()找不到字串时返回 std::npos
- 正确追加字符：s+ = 'a'
- 执行clear()后，capacity()值保持不变
- compare(s1,s2)：返回0，说明s1==s2；返回-1，说明字典序s1 < s2；返回1，字典序s1 > s2
- insert函数的重载形式合法的是：s.insert(2,5,'X')
- 编译时常量constexpr

## 数据抽象与类
### QA summary
- 类成员public private protected声明顺序任意
- 调用类的成员函数：对象名.成员函数名 或者 类名::静态成员函数名
- 静态成员必须在类外进行初始化，只能访问静态成员变量（非静态都可访问）
- 静态成员属于类本身，非静态成员属于对象
- 静态成员的作用域为整个程序
- 一个类可以有任意个构造函数但只能有一个析构函数
- {{}}嵌套，内部的{}构成一个局部作用域，内部元素在{}内构造和析构，不在最终析构
- 构造函数不能有返回值类型，可以重载，可以有默认参数
- 静态成员函数不能访问this指针（类级别操作），静态成员变量可以是const
- static局部变量只初始化一次，生命周期从第一次初始化开始到程序结束，在函数调用途中不会析构
- 对于以下代码：
  ```cpp
  #include<iostream>
  using namespace std;
  class A{
    public:
        static int count;
        A(){ count++;}
        ~A(){count--;}
  };
  
  int A::count=0;
  int main(){
    A a1,a2;
    cout<<A::count<<endl;>>
  }  
  ```
  输出为2：经过a1,a2两次构造，但是在输出A::count时程序还未结束，只有当程序结束才析构，故输出2，未经过析构环节
- 在C中，动态分配使用malloc(),C++中推荐使用new delete 来替代malloc与free，因为new delete可以自动调用构造与析构
- 堆内存时动态的，栈内存大小在编译时确定是固定不变的
- 堆可能产生内存碎片
- 使用new 分配数组时：new a[n]构造N次，delete []a析构N次
- new 分配单个对象时：new A构造1次，delete析构1次
- 当new[]与delete不匹配时崩溃（new数组，delete却没带[]）
- 当new-delete后再调用new指针会抛出garbage value
- 构造函数的初始化列表的初始化优先级比默认成员初始化器优先级高
- new创建的类实例在堆区，引用保存在栈区
- 实现深拷贝（手动管理资源）必须自定义：拷贝构造函数 析构函数 拷贝赋值运算符
- 一个类只能定义一个拷贝构造函数 classname(const classname& other){}

### note
#### 事物特征：数据特征（静态） 行为特征（动态）
- 抽象：思维过程 从众多事物中提取共同的**本质性**的特征，摒弃非本质特征
- 数据抽象：对现实世界的事物概念的数字化概述
- 抽象数据类型ADT:
    - 说明部分.h
    - 实现部分.cpp(外部实现)/内部实现
    - 效果：抽象类是一种封装好的数据类型，达到信息隐藏与封装的效果

#### 类的声明
- 访问说明符：public private protected
- 类成员：数据成员（被隐藏保护，private,**不声明访问说明默认private**）
- 函数成员，公有成员可被外部使用者访问，私有仅内部访问
- **const函数成员不能修改数据成员**
- struct定义的类成员默认public
- class定义的类成员默认private

- 对象objects：用户定义的数据类型，表示一个ADT
- 公有成员public:任意访问 
- 私有成员private:在类外不可访问，不可查看，只有类的**成员函数与友元函数**可以访问

- 构造函数：初始化类，无任何返回类型（无void）可带参数以便在创建对象时构造对象，默认实参 减少构造函数重载的数量
- 用户一旦定义构造函数，编译器就不自动添加默认构造函数，调用无参构造报错
- 析构函数：对象释放前执行，无返回值，无任何参数，不能直接调用

- this指针：所有成员函数的隐含参数；指向调用对象this -> a
- **static静态成员不能用this,使用 类名::成员**
- 成员函数参数与成员数据重名时必须用this； this->a(类构造的a)=a（参数a）

- 类的静态成员static:遵循正常公私有访问
- static成员是类的组成成分，不是对象的组成成分（从存储角度）
- 意味着存储在全局/静态存储区，不在对象的存储空间
- 生命周期与全局变量相同（程序启动初始化，程序结束销毁）
- 如果访问控制允许的话：可在类作用域外直接访问：：静态函数
- 静态成员变量**必须在类定义体{}；外再定义一次(类外不加static)**！！！int Date:: a=0;
- 静态成员函数只需在类内声明，无需在类外重新定义，可以使用类名::静态函数名调用（实现）
- 静态成员变量/函数没有this->(不属于对象)，用::（属于类）
- 静态成员不能访问类的非静态成员（static无this指针）但是非静态成员可以访问静态成员

**静态成员提供类级别的操作（无需指针），非静态成员提供对象级别操作（依赖指针）**

#### C++新增表示：
- Bool：0/1
- Void:表示空类型（无返回值） 
- 函数重载（相同名称不同参数类型/不等量参数√）**不同返回类型不可触发重载**！！！！
- 函数签名：编译器根据函数名、参数数目、参数类型生成唯一的内部函数类型（×返回类型）
- 默认实参：默认参数可直接定义在函数中void func(int a=1, double b=2.0){} 函数调用时不填入参数直接用默认参数
- 字符串类型string

- 程序内存布局与对象存放位置：
  正文：函数实现，库实现，字符串等资源(不可改)
  静态变量（对象）编译阶段初始化数据（用零）
  栈Stack:函数参数，自动变量（对象）
  堆Heap:动态变量（对象），由stdlib.h管理
- 函数外声明或static修饰，在全局/静态存储区作为初始化数据分配
- 在函数内声明，则在栈上分配空间并初始化
  
#### 动态对象调用
- 创建：new类型/构造函数 返回该类型指针指向新建对象（不是void*）
- new 类型[] {初始化列表}  p =new int{1,3,5} 在堆上分配对象并构造初始化
  若没有初始化列表，则调用无参构造（默认构造一般是不确定值）
  常数初始化列表，后面补零 长度小于初始化序列长度，抛出异常
- 使用：*p间接引用-解析为对象
- 释放：delete[]指针

- 关键字new delete:
- new类型：初始化 非陪空间 每个对象调用构造器 有错误抛出异常
  指针=new 类型名	//动态创建对象
  指针=new 类型名（初始化参数）//动态创建对象（参数可选）
  指针=new 类型名[数组长度] //动态分配数组

- 类型：基本类型/类类型（类类型 初始化参数相当于实际参数传递给该类的构造函数）
- **new运算返回该类型指针指向分配到的内存空间**
  若内存分配失败抛出异常
  delete p/delete []p 手动为数组每个对象析构 释放空间

- delete调用该对象的析构函数,释放指针指向对象占据的内存
- 用delete释放空间后，**指针的值仍是原来指向的地址（不修改指针的值）但指针失效（内存不可用）**
- 野指针：指向无效内存的指针（指针所指的内存已被释放或不再合法）
  访问野指针会导致未定义行为，引发程序崩溃数据损坏
- 原因：指针未初始化
  指针指向已经释放的内存
  指针超出作用域

- 函数返回局部变量地址
- 解决：初始化指针为nullptr
- 释放后置空 delete p; p=nullptr
- 使用智能指针auto: auto p = std:: make_unique<int>(42)
- 避免返回局部变量地址：直接return值，而不是return指针

- 内存泄漏：new的空间失去指针或引用，永远无法释放，导致资源耗尽

- 显式定义默认函数 =default：恢复函数的默认定义
- 当声明有参构造函数时，编译器不会创建默认构造函数，为使编译器创建该默认构造函数可以在函数声明后指定=default

- 弃置函数 =delete:
- 删除函数的默认定义，对任何弃置函数都是非良构的
- 弃置函数定义隐式内联，且=delete必须是函数的首次声明

- 成员初始化器：date(int x1):x(x1){ }
- 常量成员，引用成员，无参构造函数直接调用有参构造初始化
  顺序：严格按照类声明中的顺序来进行初始化
```cpp
Class date{int i; int j; 
public: Date(int x):i(x),j(i){} //先初始化i,再初始化j
}
```

- C++内存布局: 代码区 全局数据区 栈区 堆区
- 成员函数在代码区
- 静态成员变量在全局数据区
- 非静态成员变量在类的实例内，实例在栈区或堆区
- 虚函数表指针，虚基类指针在类的实例内，实例在栈区或堆区
- 类的实例:
    函数中定义的类变量在栈内存区
    new得到的新对象在堆内存区，其引用会保存在栈内

#### 静态联编 static binding

联编：将函数调用与函数实现关联的过程，确定调用哪个具体的函数：
    静态：**编译阶段**确定函数调用，**无法实现多态**
    动态：**运行阶段**通过**虚函数**实现确定函数调用

在编译阶段直接使用代码段函数地址调用动态对象的方法，仅仅需要向非静态成员函数传送this指针，即可用静态函数调用实现动态调用效果
- 优势：对象布局与C结构布局一致，使得内存中对象便于与其他语言程序库兼容
高效率高性能

#### 拷贝构造函数ClassName(const ClassName& other);：
用一个已存在的对象初始化一个新对象
参数：同类对象的常量引用
调用时机：当发生对象拷贝初始化时自动调用
默认拷贝构造：逐成员浅拷贝（若类内有指针成员，默认拷贝构造会复制指针值而非指向的数据，导致多个对象共享一块内存，引发双重释放或内存泄漏）
深拷贝（使用自定义拷贝函数实现）为新对象独立分配内存，复制原对象所有数据
- **包含指针一般都用深拷贝**

#### 常变量const
```cpp
const常量 constexpr
const指针：	const int**p //不能修改**p, (*p)[]
int *const *p //不能修改*p,p[]
int** const p;//不能修改p
const函数： int foo (const int i) //不能修改函数参数
const int* foo();//返回const指针，必须强制类型转换赋值给非const指针
```
const引用左值对象：为变量取别名，不可修改：const int&size=i //size是i的别名
const引用右值对象：为值取别名，不可修改（为右值对象开辟临时空间并赋予别名）
const引用一般用于函数的参数和返回值
作为函数形式参数，实参可以是左值或者右值（含隐式转换）
作为返回值是返回对象的别名

## 运算符重载
### QA summary
- C++不允许内置类型的运算符（如int+int行为不能重载，只能重载类类型）
- 重载运算符时运算符目数固定，不能变（单目 -> 双目×）
- 重载赋值运算符时通常返回当前对象的引用：
    支持链式赋值，避免不必要的拷贝，与内置行为一致

【判断返回值类型】
- 是否需要链式操作：是 -> 返回引用（=，+=）不是 ->可以返回void(<)
- 是否需要避免拷贝：是 ->返回引用 不是 -> 可以返回副本
  
- 当同名函数：非const对象优先调用非const函数，const版本不被调用
- 从自身可修改性，对数据的访问权限等角度考虑a特性：
    1.int& a = b 相当于 const int* a = &b × 引用不可重新绑定，可修改数据；指针相反 
    2.const int& a = b 相当于 const int* const a = &b√均不可绑定，均不可通过a改目标数据
- 函数对象是一个对象但是使用形式看起来像函数调用，实际上也执行函数调用


### note
**增强代码可读性**
定义：重载具有特殊函数名（以运算符为函数名）的函数
两种方法：
1. 类成员函数运算符重载-成员运算符函数
Return_type class_name:: operator op(operand2){ }
Return_type operator op (operand1, operand 2){ }
·重载二元op时成员运算函数只需要显示传递一个参数（右操作数）左操作数作为类对象本身通过this指针隐式传递 A+B <==> A.operator +(B)
·重载一元op时成员运算函数没有参数，操作数时类对象本身，通过this指针隐式传递
-A <==> A.operator - (B)

·**可以重载的运算符**：
    算数（+ - * / %）关系运算符（> < == != ...） 
    逻辑运算符（|| && ！）
    位运算符（| & ~ ^(按位异或) << (左移)>>） 
    单目运算符（+正 -负 *指针 &取地址）
    自增自减（++ --）
    赋值（=，+=，-=，8=，/=，%=，&=，|=，^=，<<=）
    其他运算符（()函数调用 ->指向成员访问 ,逗号 []下标）

下标运算符[]必须以成员函数的形式进行重载
R& T::operator[](S b); //[]可以访问元素，也可以修改元素
const R& T::operator[](S b) const; //[]只能访问元素 不能修改元素

·**不可重载运算符**
    ::  作用域解析							
    .   成员访问						 
    ?:  三元条件
    .*  通过成员指针的成员访问		 
    sizeof（除new delete外的）关键字运算符
    #   预处理符号 						
    自创的新运算符

对于双目运算：左操作数不是自定义类的对象，右操作数是
大多数运算符都可以类外定义

2. 友元函数运算符重载-普通运算符函数
友元函数friend return_type function_name(parameter_type_list){ }
友元函数**不属于类**，可以访问类的变量及函数（包括私有变量） **需要在类外实现**

类的成员函数也是函数的一种，其他类的成员函数也可以是友元函数
直接声明友元类：一个类A可以将另一个类B声明为自己的友元，那么类B的所有成员函数都可以访问类A对象的私有成员
```cpp
Class A{}；
Class B{
Public：
Friend A;
};
```
**选择：成员函数重载 or 友元函数重载**
|运算符类型	|重载方式	|理由|
|--|--|--|
|赋值 += -=|	成员函数	|需要修改对象状态，左操作数必须是当前类对象|
|下标[]	|成员函数	|必须作用于对象|
|流操作 << >>	|友元函数	|左操作数是流对象（如cout）无法用成员函数实现|
|算数对称运算+ -	|友元函数|	支持a+b a-b的对称性|
|比较 == <	|友元函数	|通常不修改对象状态，可能需要访问双方私有成员|

必须使用成员函数重载：赋值 函数调用() 成员访问-> 下标[]
    ·运算符修改对象状态 成员函数
    ·需要支持a@b b@a 友元函数
    ·左操作数是非类类型（int等） 友元函数

隐式转换：编译器在无需显示类型转换的情况下，自动将一种类型转换为另一种类型
·触发场景：参数传参时/运算符操作数/初始化或赋值时 类型不匹配
1. const:非const对象可隐式转换为const,const不能转非const
2. nullptr:nullptr_t可以隐式转换为任何指针或成员指针类型，避免NULL与0的二义性
3. explicit禁止隐式转换：标记构造函数或转换函数为显式转换，禁止编译器自动调用

## 继承与派生
- 使用using声明可以改变基类成员在派生类的访问权限
- 友元关系不可继承：基类的友元不会自动成为派生类的友元；派生类的友元也不自动成为基类友元；友元关系是非传递的支队声明它的类有效
- protected可以访问基类的public,不能访问基类的private
- 构造函数顺序：从基到派，从左到右，class Z： public Y,public X{Z()} 构造顺序：Y,X,Z
- 派生类构造拷贝函数时：先积累拷贝构造，后派生类拷贝构造
- 基类构造函数为protected,基类无法直接对象实例化，派生类不必须显式调用基类构造函数
- 当基类没有默认构造函数或需要传递参数时才需要显式调用

- 对于以下代码：
  ```cpp
  class A{
    public:
        A(){cout<<"A";}
        ~A(){cout<<"~A";}
  };
  class B: public A{
    public:
        B(){cout<<"B";}
        ~B(){cout<<"~B";}
  };
  int main(){
    A* p=new B();
    delete p;
  }
  ```
- 输出为AB~A：new B()调用A构造函数，再调用B构造函数；delete p由于p是A*且A的析构函数**不是虚函数**，因此只会调用A的析构函数，不会调用B的，导致派生类部分资源未被释放，内存泄漏

- 如果一个类继承自非虚类，且没有使用作用域解析运算符，那么该类实例对象上访问同名成员时会自动调用派生类成员
- 构造函数调用顺序：虚函数 -> 非虚函数 基类 -> 派生 左 -> 右
- 菱形继承问题通常通过虚继承解决
- 若一个派生类和它的非虚基类有同名的成员函数，可以使用基类名+作用域解析运算符直接调用基类的成员函数

**指针const的兼容性**：
非const-> const：安全，T*可以隐式转换为const T*，添加const限定符不破坏数据完整
const-> 非const：禁止，const T*不能隐式转换为T*

**引用与值的兼容性**
引用T&与T不能隐式互换，T&必须转换到已有对象；引用必须显式绑定

**对象与指针的兼容性**
对象T不能直接赋值给指针 ’ T*
指针需要内存地址，而对象是值类型，二者不兼容

- C++类型转换与未定义问题：
1. const_cast不对已经const的成员使用
2. reinterpret_cast注意双关行为
3. 向下转型使用动态dynamic_cast
4. 注意数组与指针的越界转换

- 多重继承中，若两个基类有同名函数show()派生类未重写，调用d.show()编译错误，二义性

### note
继承使用情况：类B的全部特性在定义时发现已经在类A中全部写好，同时类B中还有类A没有的特性时，将类A设计成一个“基类”，类B设计为基类的一个“派生类”

·效果：**基类的所有成员自动成为派生类的成员**
派生类通过对基类进行扩充与修改得到
·面向对象编程的基础，通过封装分离开发者和使用者

#### 单继承
```
Class 派生类名：继承访问控制 基类类名{
成员访问控制：
成员声明列表；
};
```
继承访问控制：public、protected、private, **默认为private (和类内定义是一样的)**
Private:声明后为私有成员，私有成员只能通过本类成员函数来访问
Public:公有成员用于描述一个类与外部世界的接口，类外可以直接访问公有
Protected:对于派生类成员来说是public,对于外部成员来说是private
**protected成员只能由本类及其派生类成员函数访问**
**基类私有成员不可以在派生类中访问**
**继承访问控制影响外部类对派生类继承成员的访问控制**

派生类总是先进行基类部分的初始化，默认使用基类无参构造
**基类的构造函数不被继承，派生类需要定义自己的构造函数**：
	只需对本类中新增成员进行初始化
调用基类的构造函数对参与的基类成员进行初始化

派生类构造函数顺序：调用基类的构造函数 -> 调用本类的对象成员的构造函数 -> 调用本类的构造函数
派生类析构：（与构造相反）本类析构 -> 本类对象成员析构 -> 基类析构

派生类不可继承基类的：1.私有成员 2.构造函数 3.析构函数
若基类构造函数带参数，在定义派生类构造函数时，必须通过初始化列表显式调用基类构造函数，并向基类构造函数传递实参
```
	派生类名（形参表）：基类名（实参表）{
		派生类新成员初始化赋值语句；
	}
```

派生类同名成员函数处理:
1. 重载：在同一作用域中函数名相同但参数列表不同
    编译器根据调用时的实参选择最匹配函数；
    仅在同一类内有效，派生类与基类同名函数不构成重载
2. 覆盖override：派生类重写基类的虚函数，要求函数名、参数列表、返回类型完全相同
    基类函数必须是virtual
    通过基类指针调用时，实际执行派生类版本
3. 隐藏：派生类定义了与基类同名的函数（无论参数是否相同）屏蔽基类的同名函数
    如果派生类有同名函数，基类的所有同名函数（包括充在版本）都会被隐藏
    调用时不会考虑基类的同名函数（除非显式指定作用域）

**继承中的函数查找规则：**
先查找派生类，如果找到：  参数匹配直接调用/**不匹配不会继续查找基类（Hide基类）**
                        如果未找到：向上查找基类，按普通继承规则处理

**避免hide问题**
1. using引入基类
2. 显式调用d.Base::func();
3. 使用override覆盖
   ```cpp
   class Derived: public Base{
   public:
        void show() override {cout<<”Derived::show()”<<endl;}
    };
   ```

类型兼容性：
规则一：对象赋值运算兼容性：可以将后代类的对象赋值给祖先类对象（反之不可）
规则二：    
        基类类型指针或引用也可指向/引用公有派生类型的对象
        只有公有派生类才能兼容基类类型

对象的类型转换:
向上转型：Upcasting，向上/基类型转换：将派生类对象视为基类对象
·将派生类的对象/指针赋值给基类的对象，允许隐式转换
向下转型：将基类对象视作派生类对象

·需要显式转换，一般使用运算符
```cpp
dynamic_cast p1 = dynamic_cast<Circle*> (p);
```
·静态类型转换：编译期间完成的类型转换操作，显式将一种类型转换为另一类型
```cpp
average = (float) hits / (float) at_bats; 
average = static_cast<float>(hits) / static_cast<float>(at_bats);
```
·const_cast:用于去除常指针/引用的常量性：
const常量特性：	是变量，可以通过指向这个常变量的指针改变常变量的值；
是常量，直接使用这个常变量的名字仍然是原来的常量值

·reinterpret_cast重新解释表示数据的二进制位串
·dynamic_cast 动态类型转换，运行时检查类型安全（转换失败返回NULL）支持向下转型
常用于对含有虚函数的抽象类进行向下转型

#### 多重继承
派生类有多个基类
```cpp
虚基类：	class Base{}
class Base1: virtual public Base{}
class Base2: virtual public Base{}
class Derived : public Base1, public Base2{}
```
构造顺序：1.先基类后成员 2.先虚后实 3.先左后右
析构顺序：与构造相反

## 多态
### QA sunmary
- 虚函数本质是动态绑定（运行时多态），依赖对象的动态类型（通过虚函数表现）
- 静态成员函数属于类而非对象，没有this指针不能访问对象的虚函数表，不能是虚函数
- 虚函数可以在构造函数中被调用，可以在纯虚函数中声明，可以被override覆盖再派生类中
- 实现多态的方式：虚函数，重写override(覆盖)
- 动态类型决定实际调用哪个函数版本
- virtual void f() final; 表明“该函数为最终覆盖，禁止后续派生类再次覆盖”

- 抽象类定义或继承至少一个纯虚数且不能被实例化
- 不能定义其对象是抽象类的特性
- 纯虚函数是一个在基类中说明的虚函数，再该基类中没有定义但是要求所有派生类都定义自己的版本
- 若基类的析构函数是虚函数，则派生类的析构函数自动成为虚函数
- **C++接口interface**:纯虚函数，不能实例化，无成员变量，强制派生类实现特定方法

- 以下代码
```cpp
#include<iostream>
#include<typeinfo>
using namespace std;

class Base{virtual void func(){} }; //基类（含虚函数）
class Derived : public Base(){ }; //派生类

int main(){
    Base *ptr =new Derived(); //基类指针指向派生类对象
    cout<<typeid(ptr).name<<endl;
    cout<<typeid(*ptr).name<<endl;
    return 0;
}
```
输出为：
- typeid(ptr).name输出静态类型（编译时类型），实际类型为Base*指针
- typeid(*ptr).name输出动态类型（运行时类型），实际返回指向的对象类型
  
- dynamic_cast转换失败：若转换类型为指针，则返回nullptr;若为引用，抛出bad_cast异常
- final类：禁止继承
- final虚函数：禁止覆盖，非虚函数不能用final,继承final类直接导致编译错误

### note
多态特指一个标识符指代不同的行为/不同类型的数据
其语义主要看上下文语境（类型决定标识的行为）

**基类指针指向派生类对象**，对于实现多态性行为十分关键
·静态类型：变量或表达式的声明类型（编译时确定）**向下转型：派生类->基类**
    特点：	由变量定义时的类型决定
    编译器在编译阶段就能确定
·动态类型：指针或引用实际指向的对象类型（运行时确定）**向上转型：基类->派生类**
    特点	只有在运行时才能确定
    仅适用于指针或引用（普通对象没有动态类型）
·判断：如果基类没有虚函数返回静态，有返回动态
    使用dynamic_cast(需要基类有虚函数)判断动态类型
多态的核心：动态绑定

**如何判断动态绑定：**
    基类函数是virtual
    通过指针或引用调用
	派生类覆盖override了基类的虚函数

纯虚函数： 使用“=0”作为虚函数声明的后缀，表示该函数纯虚
    ·纯虚函数可以（不建议）给定义，若是虚构则必须定义

抽象类：定义或继承了至少一个纯虚函数的类
    ·抽象类不可以实例化
    ·抽象类的子类也是抽象类，除非所有纯虚函数被override为非纯虚函数
    ·能够声明指针或引用指代自己的派生类对象
    ·不能定义抽象类的对象 Animal a×
    ·不能显示转换为抽象类对象 （Animal）dog ×
    ·不能作为函数参数类型或者返回值 func(Animal) ×

**函数重载与函数覆盖核心区别**

|特性	|函数重载overload	|函数覆盖override|
|----|----|---|
|定义	|同一作用域内，函数名相同但是参数列表不同	|派生类重新定义基类虚函数，函数签名完全一致|
|目的	|提供统一功能的多种实现方式	|实现运行时多态，允许通过基类指针/引用调用派生类的特定实现|
|作用域	|同一作用域内	|跨继承（基类&派生类）|
|继承要求|	不依赖继承关系|	必须继承自包含虚函数的基类|
|多态类型|	编译时多态（静态绑定）	|运行时多态（动态绑定）|
|绑定时机|	编译时根据参数类型决定调用哪一个函数	|运行时根据对象的实际类型（动态类型）决定调用哪一个函数|
|签名	|参数列表必须不同，返回类型不限	|函数签名完全一致|
|关键字	|无|	基类函数virtual 派生类可override|

## 模板template
### QA summary
- 同时存在模板与非模板，调用优先匹配非模板
- 非类型模板形参的特点是：必须是编译时常量表达式；例如：stack< int,10 >中“10”是非类型模板形参
- 包含编译模式要求：模板定义在调用处可见
- 模板重载的优先级顺序：非模板调用> 模板特化> 通用模板
- 若同时存在普通函数与函数模板（若参数类型匹配）优先调用普通函数，若不匹配普通函数再考虑模板函数；函数模板成功匹配，就实例化该函数模板，并调用
- 数组引用作为模板参数的函数定义：template< typename T,int N > void print(T(&arr))[N];

### note
泛型编程：编写独立于任何特定数据类型的数据，从而可以用相同代码处理不同类型的数据
模板：函数模板 类模板
泛型编程是一种编译时多态性（静态多态）其中数据的数据类型本身是参数化的，程序具有多态性特征。
实例化：模板编码 -> 实例编码
**函数模板不进行隐式转换**！！！

*非类型模板形参可以是以下类型：
    ​​整型​​（int、char、short 等）
    ​​指针​​（包括函数指针）
    ​​引用​​（包括对象引用）
    ​​枚举​​（enum）
C++20 起支持 ​​浮点型​​（float、double）

## STL
### QA summary
- queue:
  - push操作将元素加入队尾（FIFO）
  - pop操作移除队列的队首元素
  - front访问队首元素

- 多数实现中，vector容量按指数增长（0-1-2-4-8），如当前容器容量为4，再插入一个元素，size=5,capacity=8；此时删除一个元素，size=4,capacity=8(不随删除而改变容量)
- resize操作不会改变原本vector容器的capacity,只改变size
  
- 预留容量：a.reserve(m)，预分配至少m个元素的内存
    后续再增加元素，内存分配的增加是根据m的倍数增加的
    例如：原capacity=16,reserve(50)，在50的基础上增加16，新的capacity为100（50*2）

- shrink_to_fit()：尝试减少capacity以匹配size(capacity = size)
- priority_queue 提供优先级队列实现，默认自动降序排列，队首元素始终为最大元素
    若想使用升序：priority_queue< int,vector< int >,greater< int >> minHeap;(队首始终最小元素)

### note
·containers
·iterators
·algorithms

Vector< T > 动态连续数组（动态指长度可变）（连续指可以用T*访问元素）
迭代器是用于遍历容器元素的指针的包装
·auto: 占位符类型说明符 auto x=expr
·decltype（expr）说明符：声明从表达式推导得到的类型

#### 容器
容器是存储其他对象的对象
分为：序列式容器 关联式容器 无序关联式容器 容器适配器
顺序容器：Array(固定长度) vector deque forward_list list
1.序列式容器：
Vector List deque

2.关联式容器：
Map/Dict（映射/字典）：Key关键字 value映射值 Pair/item对/项
Set集合：元素不重复,不支持下标操作，没有定义mapped_type类型，set容器定义的value_type类型不是pair类型，而是与key_typw相同，都是set中元素的类型
Multimap:不支持下标操作，键相同元素相邻存放

Auto p = make_pair(v1,v2)，通过p.first访问第一个元素，p.second访问第二个元素
迭代器：每种容器各自定义的一个或多个不同于容器的类

3.容器适配器：
容器适配器提供顺序容器之上的不同功能接口（界面）

#### 迭代器
输入迭代器：读 输出迭代器：写
For (const auto& x : container) {...}

#### 算法
Sort(vec.begin(),vec.end(),greater())
Count_if(vec.begin(),vec.end(),[](int i)){return i>20}

## 异常处理
### QA summary
- 异常处理的“检测与处理分离”思想指：一个函数可以只负责检测并抛出异常，而具体处理任务交给其**调用链上层的函数**完成
- try-catch匹配：一个异常抛出，程序先执行第一个类型匹配的catch块，跳过其他catch块
- catch块中，使用 catch(const exception& e)相较于catch(exception e)捕获异常，优势在于按引用捕获可以避免额外的对象拷贝开销，防止“对象切片问题”
- 若一个声明为noexcpet的函数实际抛出异常，程序会立即terminate
- catch块中，若要将捕获到的异常原封不动重新抛出，使用throw,不带任何表达式的throw关键字
- 一个继承自exception的自定义异常也可以被excpetion的catch块处理

## note
程序错误：
1.编译或静态分析错误：
·语法错误（无法编译）
·逻辑错误：习惯不良（如new-delete不配对）
2.运行错误：
·逻辑错误：程序正常运行但未得到期望输出
·运行异常：可以检测：内存分配失败，文件读写错误，除零，指针操作越界
难以预测：段错误，栈溢出

程序终止
·正常终止：执行正常结束而终止
·异常终止：程序执行中发生错误或特殊事件而终止
可预测的错误/用户自己定义的错误/难以预测的错误

【异常处理】
采用**结构化方法**对程序的运行时错误进行显式管理：
错误类别：处理的是可预测的错误或特殊事件
效果：将程序中的正常处理代码与异常处理代码显式区分开来，提高程序可读性
结构化定义异常：将异常种类定义为树状结构
结构化处理异常：异常检测与异常处理分离
    **抛出异常的程序段： throw 表达式**
    **捕获并处理异常的程序段**：
    try 复合语句（保护段） 
    catch（异常类型声明）
    复合语句 
    catch（异常类型声明）
    复合语句
```cpp
try{ 
    //可能抛出异常的代码
    throw SomeException(“Error message”);//抛出异常
}

catch(const someException& ex){ 
    //处理SomeException类型的异常
    cerr<<ex.what()<<endl;
}
catch(...){ 
    //捕获所有未被处理的异常{
    cerr<<"unknown exeption"<<endl;
}
```
throw 抛出异常 通常抛出派生自exception的类,如：
    Throw 42;
    Throw “something went wrong”;
    Throw runtime_error(“Oops!”); //标准异常

#### 标准异常类

Exception 		所有标准异常的基类
Runtime_error	运行时错误（如文件未找到）
Logic_error		逻辑错误（如无效参数）
Bad_alloc		内存分配失败（new抛出）
Out_of_range	数组/容器越界访问


#### summary
Summary:
·throw:抛出异常（内置类型、标准异常或自定义类）
·try-catch:捕获并处理异常（支持多级捕获）
·标准异常：优先使用exception派生类
·自定义异常：继承exception实现what()
#include <stdexcept>
Logic_error
Runtime_error

#### 异常传播
异常从抛出点（throw）到捕获点（catch）的传递过程，=
·基本原则：
1. 调用栈展开
当异常被抛出时：程序立即停止当前执行流；
        从当前函数开始，**沿调用栈向上查找**匹配的catch块
        如果找到匹配的catch，执行该块代码并继续程序
        如果无法匹配，调用terminate()终止程序

2. 局部对象析构
栈展开过程中**所有局部对象的析构函数**都会被调用

【异常传播路径】
1. 单层传播：异常在**同一个函数的try-catch块**中处理
2. 跨函数传播：异常通过**调用栈向上传播**，直到被捕获
3. 未被捕获的异常：如果异常未被任何catch捕获，终止程序terminate()

【多级catch匹配规则】
1. 按顺序匹配：catch块从上到下检查，第一个匹配的类型被执行
2. 基类捕获所有派生类异常：catch(const std::exception& )可以捕获任何标准异常
3. catch(...)捕获所有未被处理的异常（用于日志或清理）

【异常传播中的资源管理（RAII）】
问题：如果一场传播导致函数提前推出，确保资源被释放
解决方案：使用RAII封装资源

【阻止异常传播的机制】
1. noexcept函数：标记函数不抛出异常，用于优化性能或强制契约
2. 捕获并处理所有异常catch(...) 